//closer 안쪽 함수는 바깥 함수의 참조를 가져올 수 있다.
// 외부변수를 기억하고 이 외부 변수에 접근할수잇는 함수를 의미함
// '클로저(closure)'는 개발자라면 알고 있어야 할 프로그래밍 용어입니다.

// 클로저는 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미합니다. 몇몇 언어에선 클로저를 구현하는 게 불가능하거나 특수한 방식으로 함수를 작성해야 클로저를 만들 수 있습니다. 하지만 자바스크립트에선 모든 함수가 자연스럽게 클로저가 됩니다. 예외가 하나 있긴 한데 자세한 내용은 new Function 문법에서 다루도록 하겠습니다.

// 요점을 정리해 봅시다. 자바스크립트의 함수는 숨김 프로퍼티인 [[Environment]]를 이용해 자신이 어디서 만들어졌는지를 기억합니다. 함수 본문에선 [[Environment]]를 사용해 외부 변수에 접근합니다.

// 프런트엔드 개발자 채용 인터뷰에서 "클로저가 무엇입니까?"라는 질문을 받으면, 클로저의 정의를 말하고 자바스크립트에서 왜 모든 함수가 클로저인지에 관해 설명하면 될 것 같습니다. 이때 [[Environment]] 프로퍼티와 렉시컬 환경이 어떤 방식으로 동작하는지에 대한 설명을 덧붙이면 좋습니다.

// lexical environment - 자바스크립트가 어떻게 동작하는지 설명하는 데 쓰이는 ‘이론상의’ 객체

//outer 함수에 대한 execution environment는 runtime 중에 계속 열려있다
function outer() {
  let x = 10;

  return function inner() {
    return x;
  };
}
const number = outer();
number(); //----> function inner() 가 된 것과 같음

//
/* -------------------- */
/* 클로저(Closures)       */
/* -------------------- */

// 클로저 (closure) 란?
// - JavaScript의 매우 강력한 특성으로 독립적인 변수를 참조하는 함수를 말합니다.
//   즉, 클로저에 정의된 함수는 그것이 작성된 환경을 '기억'합니다.
// 함수는 태어난 환경을 기억한다.
// 가비지 컬랙터가 더이상 수집 못하게 함

function sum(a, b) {
  return a + b;
}

const value = sum; ////----> 함수본문을 넘긴다

function first() {
  let x = 10;
  function second() {
    let y = 20;
    return x + y;
  }
  return second;
}

const resultValue = first();

/*
function counter() {
  let count = 0;
  console.log(++count);
}

counter()   //->closure을 사용하지 않으면 그대로 휘발된다
*/

function counter() {
  let count = 0;
  let count2 = 0;
  function inner() {
    console.log(++count);
  }
  return inner;
}

const c1 = counter(); //
c1(); //1
c1(); //2
c1(); //3
const c2 = counter(); //다른 환경을 만들기 때문에 새로 1로 시작
c2(); //1
c2(); //2
c2(); //3

//함수를 여러번 실행 currying function first()()

// 모든 함수에는 실행 컨텍스트가 있습니다. 실행 컨텍스트는 해당 함수 내의 변수와
// 해당 부모 환경에 대한 참조를 의미하는 환경으로 구성됩니다. 상위 환경에 대한 참조는
// 내부 함수가 작성된 범위 외부 또는 내부에서 호출되는지 여부에 관계없이 상위 범위의
// 모든 변수를 모든 내부 함수에 사용할 수 있게 합니다.
//
// 따라서 함수가 사실상 환경(해당 환경에 정의된 변수)에 대한 참조를 가지고 있기 때문에
// 함수가 이 환경(또는 영역(scope))을 "기억"하는 것처럼 보입니다!
//
// 모든 실행 컨텍스트에는 어휘 환경(Lexical Environment)이 있습니다.
// 이 어휘 환경은 식별자 바인딩(즉, 변수 및 관련 값)을 보유하고 있으며
// 외부 환경에 대한 참조도 가지고 있습니다.
//
// 각 환경이 접근 할 수 있는 일련의 식별자를 "범위(Scope)"라고 합니다.
// 이러한 범위를 "스코프 체인(Scope Chain)"을 통해 계층적 환경 체인에
// 중첩 할 수 있습니다.

// 어느 시점이든 하나의 실행 컨텍스트만 실행 될 수 있습니다.
// 이것이 JavaScript가 "단일 스레드"인 이유입니다.
//
// 즉, 한 번에 하나의 명령만 처리 할 수 있습니다. 일반적으로
// 브라우저는 "스택(Stack)"을 사용하여 이 실행 컨텍스트를 유지 관리합니다.
// 스택은 LIFO(Last In First Out) 데이터 구조입니다.

//
// 스택에 푸시(push) 한 마지막 것이 가장 먼저 꺼내집니다. 스택의
// 맨 위에 요소만 삽입하거나 삭제할 수 있기 때문입니다. 현재 또는
// "실행 중인" 실행 컨텍스트는 항상 스택의 맨 위에 있는 항목입니다.
//
// 실행 중인 실행 컨텍스트의 코드가 완전히 평가되면 최상위 항목이
// 팝(pop) 된 다음 실행 항목이 실행 컨텍스트를 실행하는 것으로
// 간주됩니다.
//
// 또한 실행 컨텍스트가 실행되고 있다고 해서 다른 실행 컨텍스트를
// 실행하기 전에 실행이 완료되어야한다는 것을 의미하지는 않습니다.
// 실행 중인 실행 컨텍스트가 일시 중단되고 다른 실행 컨텍스트가
// 실행 중인 실행 컨텍스트가되는 경우가 있습니다.
//
// 일시중단 된 실행 컨텍스트는 나중에 중단 된 부분을 선택합니다.
// 한 실행 컨텍스트가 이와 같이 다른 컨텍스트로 대체 될 때마다
// 새 실행 컨텍스트가 만들어져 스택에 푸시되고 현재 실행 컨텍스트가 됩니다.

// [ 실행 컨텍스트 N + 3  ] ⬅︎ 현재 실행 컨텍스트
// [ 실행 컨텍스트 N + 2  ]
// [ 실행 컨텍스트 N + 1  ]
// [ 실행 컨텍스트 N      ]
// [ 실행 컨텍스트        ] // 글로벌
